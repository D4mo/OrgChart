# OrgChart

*******
Overview
*******

A fast, robust and easily extensible organization chart layout library without any 3-rd party dependencies.
Designed specifically for arrangement of rectangular boxes and connectors, 
for use by applications which represent hierarchical organizational structures in a user-friendly manner.

Supports combining arbitrary layout styles with some available out of the box and with open interfaces for extension/new styles, 
special layout rules for assistants, expand-collapse operations, pluggable box rendering algorithms. 
All calculations made using double-precision coordinates.

Available in C# and JavaScript (JS code is generated from C# using Bridge.Net).
All code (including C# -> JS converter) is in one Visual Studio solution.
C# version has advanced demo and debugging tool built on top of OrgChart as a Windows Universal application, 
that helps to visualize and debug layout computation process step-by-step.

JavaScript demo page generates a 200-box chart and renders it into a collection of pure HTML/div objects 
with absolute coordinates as computed by OrgChart library - you can build rich HTML5 user interfaces the way your users want it.

Use OrgChart if you need to
- render rich interactive organizational charts in a cross-browser HTML5/CSS client application, with data supplied in any format
- implement advanced organizational charting UI in a native client Windows Forms, WPF, Universal, Xamarin application
- render organizational charts in a .NET or JavaScript-based server application
- implement and debug custom layout styles and diagram layout optimization behavior with minimal effort in C#, then instantly port them to JavaScript

*******
Author and license
*******

(c) Roman Polunin 2016
MIT license

*******
Advantages
*******

Absolutely free to use and modify in all types of applications, in source code and binary form.
Exactly same code is available both in JavaScript and in C#, compiles to .NET 2.0 and 4.0, .NET Core, UWP, Silverlight etc.
As non-intrusive as possible, you can have your data structured in any way you want.
Does not force you into any specific rendering technique/framework - use whatever suitable.
Output of the library is a set of double-precision coordinates and rich supplementary layout information.

Rich API for extensibility, supports development of custom layout strategies.

*******
Usage: C#
*******

To compute chart "fresh":
1. Either import source code or plug in NuGet package called "RomanPolunin.OrgChart".
2. Implement two adaper interfaces: IChartDataSource and IChartDataItem.
3. Create an object of type BoxContainer supplying your IChartDataSource, it will produce a set of Box objects, one per IChartDataItem.
4. Either manually apply sizes on each Box (Box.Size property), or implement a callback function on LayoutState (see step 6).
5. Create an object of type Diagram and populate LayoutSettings, and also DefaultLayoutStrategyId and DefaultAssistantsLayoutStrategyId.
6. Create an object of type LayoutState, optionally give it a callback function for box size, invoke LayoutAlgorithm.Apply on that state object.
7. Consume computed coordinates from Diagram.VisualTree.

To re-compute layout after having some box collapsed or some Size modified on a Box:
1. Create an object of type LayoutState, optionally give it a callback function for box size, invoke LayoutAlgorithm.Apply on that state object.
2. Consume computed coordinates from Diagram.VisualTree.

LayoutAlgorithm.Apply will create a visual tree of BoxTree.TreeNode objects that have all computed coordinates,
available through VisualTree property of the Diagram object you created and supplied into LayoutAlgorithm.Apply. 
LayoutAlgorithm.Apply computes both coordinates of BoxTree.TreeNode objects and connectors between them.

Box carries:
- LayoutStrategyId: to explicitly assign a layout strategy to a specific box.
- DataId: identifier of the IChartDataItem used to create this Box.
- Id: identifier of this Box in its parent BoxContainer.
- Size: width and height of this box, as you want it to be. You only have to supply the size for data-bound boxes (generated from IChartDataSource).
- IsCollapsed flag: set it to true if you want corresponding chart node to be collapsed, hiding all children.
- IsAssistant flag: set it to true if you want corresponding chart node to be laid out using special assistant rule (visually separates from other normal children).
- IsSpecial flag: is automatically set to true on boxes auto-generated by the algorithm. 
  BoxContainer will only store one "special" box for the system root. Other special boxes only exist within the generated visual tree.

Diagram.VisualTree is a tree of BoxTree.TreeNode objects joined into a navigable tree structure.
Each node is a visual object on a diagram. Some of the nodes represent real data-bound boxes, some others are generated for layout purposes (spacers).
Node carries:
- Element property: pointer to corresponding Box (either IChartDataItem-bound or auto-generated).
- AssistantsRoot property: a special Node auto-generated to carry children with IsAssistant flag set to true, and their connectors.
- State property (see below).
- Children: collection of child nodes.

BoxTree.TreeNode has a State property (NodeLayoutInfo) which carries:
- effective layout strategy object, inferred from parent node or from explicit LayoutStrategyId on the bound Box.
- original size of the data-bound Box bound to it (or auto-generated for special Nodes/Boxes).
- calculated position of the Box.
- calculated bounding rectangle of entire branch (this node and all its children).
- Connector property, a collection of Edge objects that define visible connectors.

*******
Usage: JavaScript
*******

Converted JS libraries are under $\JScript\OrgChart.Layout.JScript.Bridge\Bridge\output
Demo page is here: $\JScript\OrgChart.Layout.JScript.Bridge\Bridge\www\demo.html

If you modify C# code and want to update JS, just re-build JScript project from solution.