using System;
using System.Linq;
using Staffer.OrgChart.Annotations;
using Staffer.OrgChart.Misc;

namespace Staffer.OrgChart.Layout
{
    /// <summary>
    /// Applies layout.
    /// </summary>
    public static class LayoutAlgorithm
    {
        /// <summary>
        /// Computes bounding rectangle in diagram space using only visible (non-autogenerated boxes).
        /// Useful for rendering the chart, as boxes frequently go into negative side horizontally, and have a special root box on top - all of those should not be accounted for.
        /// </summary>
        public static Rect ComputeBranchVisualBoundingRect([NotNull]Tree<int, Box, NodeLayoutInfo> visualTree)
        {
            var result = visualTree.Roots[0].Element.Frame.Exterior;

            Tree<int, Box, NodeLayoutInfo>.TreeNode.IterateParentFirst(visualTree.Roots[0], node =>
            {
                var box = node.Element;

                if (box.AffectsLayout && !box.IsSpecial)
                {
                    result += box.Frame.Exterior;
                }

                return !box.IsCollapsed;
            });

            return result;
        }

        /// <summary>
        /// Resets chart layout-related properties on boxes, possibly present from previous layout runs.
        /// Wipes out connectors too.
        /// </summary>
        public static void ResetBoxPositions([NotNull]Diagram diagram)
        {
            foreach (var box in diagram.Boxes.BoxesById.Values)
            {
                box.Frame.ResetLayout();
            }
        }

        /// <summary>
        /// Initializes <paramref name="state"/> and performs all layout operations.
        /// </summary>
        public static void Apply([NotNull]LayoutState state)
        {
            // verify the root
            if (state.Diagram.Boxes.SystemRoot == null)
            {
                throw new InvalidOperationException("SystemRoot is not initialized on the box container");
            }

            state.CurrentOperation = LayoutState.Operation.Preparing;

            var tree = Tree<int, Box, NodeLayoutInfo>.Build(state.Diagram.Boxes.BoxesById.Values, x => x.Id, x => x.VisualParentId);

            // verify the root
            if (tree.Roots.Count != 1 || tree.Roots[0].Element.Id != state.Diagram.Boxes.SystemRoot.Id)
            {
                throw new Exception("SystemRoot is not on the top of the visual tree");
            }

            // set the tree and update visibility
            tree.UpdateHierarchyStats();
            state.AttachVisualTree(tree);

            if (state.BoxSizeFunc != null)
            {
                // apply box sizes
                foreach (var box in state.Diagram.Boxes.BoxesById.Values.Where(x => x.IsDataBound))
                {
                    box.Frame.Exterior = new Rect(state.BoxSizeFunc(box.DataId));
                }
            }

            // update visibility of boxes based on collapsed state
            tree.IterateParentFirst(
                node =>
                {
                    node.Element.AffectsLayout =
                        node.ParentNode == null ||
                        node.ParentNode.Element.AffectsLayout && !node.ParentNode.Element.IsCollapsed;
                    return true;
                });

            state.CurrentOperation = LayoutState.Operation.PreprocessVisualTree;
            PreprocessVisualTree(state, tree);

            state.CurrentOperation = LayoutState.Operation.VerticalLayout;
            VerticalLayout(state, tree.Roots[0]);

            state.CurrentOperation = LayoutState.Operation.HorizontalLayout;
            HorizontalLayout(state, tree.Roots[0]);

            state.CurrentOperation = LayoutState.Operation.ConnectorsLayout;
            RouteConnectors(state);

            state.Diagram.VisualTree = state.VisualTree;

            state.CurrentOperation = LayoutState.Operation.Completed;
        }

        private static void PreprocessVisualTree([NotNull]LayoutState state, [NotNull]Tree<int, Box, NodeLayoutInfo> visualTree)
        {
            visualTree.IterateParentFirst(node =>
            {
                if (node.Element.IsSpecial && node.Level > 0 || node.ChildCount == 0)
                {
                    return false;
                }

                var nodeState = new NodeLayoutInfo();
                node.State = nodeState;

                // first, find and associate layout strategy in effect for this node
                if (node.Element.LayoutStrategyId != null)
                {
                    // is it explicitly specified?
                    nodeState.EffectiveLayoutStrategy = state.Diagram.LayoutSettings.LayoutStrategies[node.Element.LayoutStrategyId];
                }
                else if (node.ParentNode != null)
                {
                    // can we inherit it from previous level?
                    nodeState.EffectiveLayoutStrategy = node.ParentNode.RequireState().RequireLayoutStrategy();
                }
                else
                {
                    nodeState.EffectiveLayoutStrategy = state.Diagram.LayoutSettings.RequireDefaultLayoutStrategy();
                }

                // now let it pre-allocate special boxes etc
                nodeState.RequireLayoutStrategy().PreProcessThisNode(state, node);

                return !node.Element.IsCollapsed;
            });
        }

        /// <summary>
        /// Re-entrant layout algorithm,
        /// </summary>
        public static void HorizontalLayout([NotNull]LayoutState state, [NotNull]Tree<int, Box, NodeLayoutInfo>.TreeNode branchRoot)
        {
            if (!branchRoot.Element.AffectsLayout)
            {
                return;
            }

            var level = state.PushLayoutLevel(branchRoot);
            try
            {
                if (branchRoot.ChildCount > 0)
                {
                    branchRoot.RequireState().RequireLayoutStrategy().ApplyHorizontalLayout(state, level);
                }
            }
            finally
            {
                state.PopLayoutLevel();
            }
        }

        /// <summary>
        /// Re-entrant layout algorithm.
        /// </summary>
        public static void VerticalLayout([NotNull]LayoutState state, [NotNull]Tree<int, Box, NodeLayoutInfo>.TreeNode branchRoot)
        {
            if (!branchRoot.Element.AffectsLayout)
            {
                return;
            }

            var level = state.PushLayoutLevel(branchRoot);
            try
            {
                if (branchRoot.ChildCount > 0)
                {
                    branchRoot.RequireState().RequireLayoutStrategy().ApplyVerticalLayout(state, level);
                }
            }
            finally
            {
                state.PopLayoutLevel();
            }
        }

        private static void RouteConnectors([NotNull]LayoutState state)
        {
            if (state.VisualTree == null)
            {
                throw new InvalidOperationException("Visual tree not attached");
            }

            state.VisualTree.IterateParentFirst(node =>
            {
                if (node.Element.IsCollapsed || node.ChildCount == 0)
                {
                    return false;
                }

                if (!node.Element.IsSpecial || node.Level == 0)
                {
                    node.RequireState().RequireLayoutStrategy().RouteConnectors(state, node);
                    return true;
                }

                return false;
            });
        }

        /// <summary>
        /// Moves a given branch horizontally, except its root box.
        /// </summary>
        public static void MoveChildrenOnly([NotNull]LayoutState state, LayoutState.LayoutLevel layoutLevel, double offset)
        {
            var children = layoutLevel.BranchRoot.Children;
            if (children == null || children.Count == 0)
            {
                throw new InvalidOperationException("Should never be invoked when children not set");
            }

            foreach (var child in children)
            {
                Tree<int, Box, NodeLayoutInfo>.TreeNode.IterateChildFirst(child,
                    node =>
                    {
                        var rect = node.Element.Frame.Exterior;
                        node.Element.Frame.Exterior = new Rect(new Point(rect.Left + offset, rect.Top),
                            rect.Size);
                        return true;
                    });
            }

            layoutLevel.Boundary.ReloadFromBranch(layoutLevel.BranchRoot, state.Diagram.Boxes.BoxesById);
        }

        /// <summary>
        /// Moves a given branch horizontally, including its root box.
        /// </summary>
        public static void MoveBranch([NotNull]LayoutState state, LayoutState.LayoutLevel layoutLevel, double offset)
        {
            Tree<int, Box, NodeLayoutInfo>.TreeNode.IterateChildFirst(layoutLevel.BranchRoot,
                node =>
                {
                    var rect = node.Element.Frame.Exterior;
                    node.Element.Frame.Exterior = new Rect(new Point(rect.Left + offset, rect.Top),
                        rect.Size);
                    return true;
                });

            layoutLevel.Boundary.ReloadFromBranch(layoutLevel.BranchRoot, state.Diagram.Boxes.BoxesById);
        }
    }
}